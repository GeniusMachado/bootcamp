from fastapi import FastAPI
from sqlmodel import SQLModel, create_engine, Session, select
from schemas import Candidate

app = FastAPI()

# --- DATABASE SETUP ---
# This creates a file named "database.db" in your folder
sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

# The engine is the "driver" that talks to the database file
engine = create_engine(sqlite_url)

# This runs when the app starts: It checks if tables exist, and creates them if not
def create_db_and_tables():
    SQLModel.metadata.create_all(engine)

# We run this immediately
create_db_and_tables()

@app.get("/")
def read_root():
    return "Welcome to the Persistent Screening Bot"

# --- THE NEW ENDPOINT ---
@app.post("/screen-candidate/")
def screen_candidate(candidate: Candidate):
    # 1. Transform the String "Python, Java" into a List for checking
    #    "Python, Java" -> ["python", " java"] -> ["python", "java"]
    skills_list = [skill.strip().lower() for skill in candidate.tech_stack.split(",")]

    # 2. Apply Rules (Logic)
    status = ""
    reason = ""

    if candidate.visa_sponsorship_needed:
        status = "Rejected"
        reason = "Visa sponsorship not available."
    elif candidate.years_experience < 3:
        status = "Junior"
        reason = "Added to junior pool."
    elif "python" not in skills_list:
        status = "Rejected"
        reason = "Python is required."
    else:
        status = "Accepted"
        reason = "Welcome to the interview!"

    # 3. SAVE TO DATABASE (The Magic Part) ðŸ’¾
    # We open a "Session" (a temporary connection) to the DB
    with Session(engine) as session:
        session.add(candidate)  # Prepare to save
        session.commit()        # Save changes to the file
        session.refresh(candidate) # Get the new ID generated by the DB

    return {
        "status": status,
        "reason": reason,
        "database_id": candidate.id  # Pro_of it was saved!
    }

# an endpoint to get the list of all the candidates saved in the databse
@app.get("/candidates/")
def list_candidates():
    with Session(engine) as session:
        # 1. SELECT * FROM candidate
        statement = select(Candidate)
        # 2. Execute the query
        results = session.exec(statement).all()
        return results

@app.delete("/candidates/{candidate_id}")
def delete_candidate(candidate_id: int):
    with Session(engine) as session:
        # 1. Find the candidate by ID
        candidate = session.get(Candidate, candidate_id)
        
        # 2. If they don't exist, stop
        if not candidate:
            return {"error": "Candidate not found"}
        
        # 3. Delete them
        session.delete(candidate)
        session.commit()
        
        return {"ok": True, "message": f"Candidate {candidate_id} has been deleted."}